module main;

import stdio as io;
import stdlib local;
import string local;
import options local;

public styleoptions opts; 
public bool verbose = false;

public int32 main(int32 argc, string[] args)
{
	io.printf("This is still unfinished, your selected options:")
	if (parsearguments(args))
	{
		
	}
	else
	{
		exit(-1);
	}
}

public bool parsearguments(string[] args)
{
	bool flag;
	bool namefound = false;
	for (int32 i = 0; i < elemsof(args); i++)
	{
		string arg = args[i];
		if(arg[0] = '-')
		{
			switch(arg[1])
			{
				case 't':
					if(atoi(&arg[2]) => 0)
					{
						opts.tabs = atoi(&arg[2]);
					}
					else
					{
						flag = false;
						io.puts("The number of tabs must be positive")
					}
					break;
				case 's':
					if(atoi(&arg[2]) => 0)
					{
						opts.spaces = atoi(&arg[2]);
					}
					else
					{
						flag = false;
						io.puts("The number of spaces must be positive");
						return flag;
					}
					break;
				case 'v':
					verbose = true;
					break;
				case '-'
					if(strncmp(&arg[2], "nl", 2) == 0)
					{
						if(strcmp(&arg[4], "else")  == 0)
						{
							opts.nlelse = true;
						}
						else if(strcmp(&arg[4], "opbr")  == 0)
						{
							opts.openingbracketnl = true;
						}
						else if(strcmp(&arg[4], "enbr")  == 0)
						{
							opts.closingbracketnl = true
						}
						else if(strcmp(&arg[4], "args")  == 0)
						{
							opts.argsnl = true;
						}
						else if(strcmp(&arg[4], "func")  == 0)
						{
							opts.nlbetweenfunctions = true;
						}
						else if(strcmp(&arg[4], "funcbr")  == 0)
						{
							opts.functionbracketnl = true;
						}
						else if(strcmp(&arg[4], "module")  == 0)
						{
							opts.nlundermodule = true;
						}
						else if(strcmp(&arg[4], "imports")  == 0)
						{
							opts.nlunderimports = true;
						}
						else
						{
							io.printf("Unknown option: %s\n", arg);
							flag = false;
							return flag;
						}
					}
					else if(strcmp(&arg[2], "singletarget")  == 0)
					{
						opts.singletarget = true;
					}
					else if(strcmp(&arg[2], "tabs")  == 0)
					{
						opts.tabsforindent = true;
					}
					else if(strcmp(&arg[2], "indentbr")  == 0)
					{
						opts.indentbrackets = true;
					}
					else if(strcmp(&arg[2], "spaceparens")  == 0)
					{
						opts.spacebeforeparens = true;
					}
					else if(strcmp(&arg[2], "spaceops")  == 0)
					{
						opts.spacearoundops = true;
					}
					break;
			}
		}
		else
		{
			if(namefound)
			{
				io.printf("single target formatting can only format one target at a time\n");
				io.printf("%s is not a known option\n", arg);
				flag = false;
				return flag;
			}
			else
			{
				opts.modulename = arg;
				namefound = true;
			}
		}
	}
	
	//checks
	if(namefound && !opts.singletarget)
	{
		io.printf("to format a single target, --singletarget option is required\n");
		flag = false;
		return flag;
	}
}